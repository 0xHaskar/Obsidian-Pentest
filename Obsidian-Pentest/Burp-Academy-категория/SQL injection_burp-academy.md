SQL-инъекция (SQLi) - это уязвимость в системе веб-безопасности, которая позволяет злоумышленнику вмешиваться в запросы, которые приложение делает к своей базе данных. Это может позволить злоумышленнику просматривать данные, которые он обычно не может получить.

---
## Извлечение скрытых данных
Представьте себе приложение для покупок, которое отображает товары в разных категориях. Когда пользователь нажимает на категорию подарков, его браузер запрашивает URL-адрес:
```
https://insecure-website.com/products?category=Gifts
```
Это приводит к тому, что приложение выполняет SQL-запрос для извлечения сведений о соответствующих продуктах из базы данных:

```
SELECT * FROM products WHERE category = 'Gifts' AND released = 1
```

Ограничение released = 1 используется для скрытия продуктов, которые не выпущены. Мы могли бы предположить, что для неизданных продуктов значение released = 0.

---
Приложение не реализует никаких средств защиты от атак с использованием SQL-инъекций. Это означает, что злоумышленник может создать следующую атаку, например:
`
```
https://insecure-website.com/products?category=Gifts'--
```
Это приводит к выполнению SQL-запроса:
```
SELECT * FROM products WHERE category = 'Gifts'--' AND released = 1
```
Важно отметить, что -- является индикатором комментария в SQL. Это означает, что остальная часть запроса интерпретируется как комментарий, фактически удаляя его. В этом примере это означает, что запрос больше не содержит AND released = 1. В результате отображаются все продукты, включая те, которые еще не выпущены.

С помощью аналогичной атаки можно заставить приложение отображать все товары в любой категории, включая категории, о которых оно не знает:
```
https://insecure-website.com/products?category=Gifts'+OR+1=1--
```

В результате получается SQL-запрос:
```
SELECT * FROM products WHERE category = 'Gifts' OR 1=1--' AND released = 1
```
Модифицированный запрос возвращает все элементы, в которых либо категория Gifts, либо 1 равна 1. Поскольку 1=1 всегда истинно, запрос возвращает все элементы.

---
## Подрыв логики приложения
Представьте себе приложение, которое позволяет пользователям входить в систему под именем пользователя и паролем. Если пользователь вводит имя пользователя wiener и пароль bluecheese, приложение проверяет учетные данные, выполняя следующий SQL-запрос:
```
SELECT * FROM users WHERE username = 'wiener' AND password = 'bluecheese'
```
Если запрос возвращает данные пользователя, то вход в систему выполнен успешно. В противном случае запрос отклоняется.
В этом случае злоумышленник может войти в систему от имени любого пользователя без необходимости ввода пароля. Они могут сделать это, используя последовательность комментариев SQL - чтобы удалить проверку пароля из предложения ``WHERE`` запроса. 
Например, отправка имени пользователя ``administrator'--`` и пустого пароля приводит к следующему запросу:
```
SELECT * FROM users WHERE username = 'administrator'--' AND password = ''
```

Этот запрос возвращает пользователя, чье имя пользователя является administrator, и успешно регистрирует злоумышленника как этого пользователя.

---
## SQL injection UNION attacks

Если приложение уязвимо для SQL-инъекций, а результаты запроса возвращаются в ответах приложения, можно использовать ключевое слово UNION для получения данных из других таблиц базы данных. Это широко известно как атака SQL-инъекции UNION.
Ключевое слово UNION позволяет выполнить один или несколько дополнительных запросов SELECT и добавить их результаты к исходному запросу. Например:

```
SELECT a, b FROM table1 UNION SELECT c, d FROM table2
```

Этот SQL-запрос возвращает единый результирующий набор с двумя столбцами, содержащий значения из столбцов a и b в таблице 1 и столбцов c и d в таблице 2.

Чтобы запрос UNION работал, должны выполняться два ключевых требования:

    Отдельные запросы должны возвращать одинаковое количество столбцов.
    Типы данных в каждом столбце должны быть совместимы между отдельными запросами.

Чтобы осуществить атаку SQL-инъекции UNION, убедитесь, что ваша атака отвечает этим двум требованиям. Обычно для этого необходимо выяснить:

    Сколько столбцов возвращается из исходного запроса.
    Какие столбцы, возвращенные из исходного запроса, имеют подходящий тип данных для хранения результатов инжектированного запроса.

---

## Определение необходимого количества колонок
 Когда вы выполняете атаку SQL-инъекции UNION, есть два эффективных метода определения количества столбцов, возвращаемых из исходного запроса.
 
Один из методов заключается в инъекции серии предложений ORDER BY и увеличении индекса указанного столбца до тех пор, пока не произойдет ошибка. Например, если точкой инъекции является заключенная в кавычки строка в предложении WHERE исходного запроса, вы должны отправить:
```
' ORDER BY 1-- 
' ORDER BY 2-- 
' ORDER BY 3--
etc.
```
Эта серия полезных нагрузок изменяет исходный запрос, чтобы упорядочить результаты по различным столбцам в наборе результатов. Столбец в предложении ORDER BY может быть указан по его индексу, поэтому вам не нужно знать имена столбцов. Если указанный индекс столбца превышает количество фактических столбцов в наборе результатов, база данных возвращает ошибку, например:

`The ORDER BY position number 3 is out of range of the number of items in the select list.`

Приложение может действительно вернуть ошибку базы данных в своем HTTP-ответе, но может и выдать общий ответ об ошибке. В других случаях оно может просто не вернуть никаких результатов. В любом случае, если вы можете обнаружить какую-то разницу в ответе, вы можете сделать вывод о том, сколько столбцов возвращается из запроса.

---
## Lab: SQL injection UNION attack, determining the number of columns returned by the query

1. Используйте Burp Suite для перехвата и модификации запроса, который устанавливает фильтр категории товаров.
2. Измените параметр category, придав ему значение '+UNION+SELECT+NULL--. Наблюдайте, что возникает ошибка.
3. Измените параметр category, чтобы добавить дополнительный столбец, содержащий нулевое значение:`'+UNION+SELECT+NULL,NULL--`
4. Продолжайте добавлять нулевые значения до тех пор, пока ошибка не исчезнет, а в ответе не появится дополнительный контент, содержащий нулевые значения.

### решение: `'+UNION+SELECT+NULL,NULL,NULL--`
---

## Синтаксис, характерный для конкретной базы данных

В Oracle каждый запрос SELECT должен использовать ключевое слово FROM и указывать допустимую таблицу. В Oracle существует встроенная таблица dual, которая может быть использована для этой цели. Таким образом, инжектированные запросы в Oracle должны выглядеть следующим образом:
```
' UNION SELECT NULL FROM DUAL--
```
Описанные полезные нагрузки используют последовательность комментариев с двойным тире -- чтобы закомментировать остаток исходного запроса, следующего за точкой инъекции. В MySQL за последовательностью двойного тире должен следовать пробел. В качестве альтернативы для идентификации комментария можно использовать хэш-символ #.

Более подробно о синтаксисе, характерном для конкретной базы данных, читайте в шпаргалке по SQL-инъекциям.
### #ШПАРГАЛКА!
https://portswigger.net/web-security/sql-injection/cheat-sheet

---

### Поиск столбцов с полезным типом данных
После определения количества необходимых столбцов можно проверить каждый столбец на предмет возможности хранения в нем строковых данных. Вы можете отправить серию полезных нагрузок UNION SELECT, которые помещают строковое значение в каждый столбец по очереди. Например, если запрос возвращает четыре столбца, вы можете отправить:
```
' UNION SELECT 'a',NULL,NULL,NULL-- 
' UNION SELECT NULL,'a',NULL,NULL-- 
' UNION SELECT NULL,NULL,'a',NULL-- 
' UNION SELECT NULL,NULL,NULL,'a'--
```
Если тип данных столбца не совместим со строковыми данными, инжектированный запрос вызовет ошибку базы данных, например:
```
Conversion failed when converting the varchar value 'a' to data type int.
```

Если ошибка не возникает, а ответ приложения содержит некоторое дополнительное содержимое, включая введенное строковое значение, значит, соответствующий столбец подходит для извлечения строковых данных.

---

## Lab: SQL injection UNION attack, finding a column containing text

Эта лабораторная работа содержит уязвимость SQL-инъекции в фильтре категорий товаров. Результаты запроса возвращаются в ответе приложения, поэтому вы можете использовать атаку UNION для получения данных из других таблиц. Чтобы построить такую атаку, сначала нужно определить количество столбцов, возвращаемых запросом. Это можно сделать с помощью техники, которую вы изучали в предыдущем задании. Следующим шагом будет определение столбца, который совместим со строковыми данными.

В лабораторной работе будет дано случайное значение, которое нужно заставить появиться в результатах запроса. Чтобы решить задачу, выполните атаку SQL-инъекции UNION, которая вернет дополнительную строку, содержащую указанное значение. Эта техника поможет вам определить, какие столбцы совместимы со строковыми данными.

1. Используйте Burp Suite, чтобы перехватить и изменить запрос, устанавливающий фильтр категорий товаров.
2. Определите количество столбцов, возвращаемых запросом. Убедитесь, что запрос возвращает три столбца, используя следующую полезную нагрузку в параметре category:
	`'+UNION+SELECT+NULL,NULL,NULL--`
3. Попробуйте заменить каждый ноль на случайное значение, например, предоставленное лабораторией:
	`'+UNION+SELECT+'abcdef',NULL,NULL--`
4. Если возникла ошибка, перейдите к следующему null и попробуйте выполнить его.

---

## Использование атаки SQL-инъекции UNION для получения интересных данных

Когда вы определили количество столбцов, возвращаемых исходным запросом, и выяснили, какие столбцы могут содержать строковые данные, вы сможете получить интересные данные.
Предположим, что:

    Исходный запрос возвращает два столбца, оба из которых могут содержать строковые данные.
    Точкой введения является строка в кавычках в предложении WHERE.
    База данных содержит таблицу users со столбцами username и password.

В этом примере вы можете получить содержимое таблицы пользователей, введя данные:
```
' UNION SELECT username, password FROM users--
```
Чтобы выполнить эту атаку, вам нужно знать, что существует таблица users с двумя столбцами, называемыми username и password. Без этой информации вам придется угадывать имена таблиц и столбцов. Все современные базы данных предоставляют возможность изучить структуру базы данных и определить, какие таблицы и столбцы в ней содержатся.

---
## Lab: SQL injection UNION attack, retrieving data from other tables

Эта лабораторная работа содержит уязвимость SQL-инъекции в фильтре категорий товаров. Результаты запроса возвращаются в ответе приложения, поэтому вы можете использовать атаку UNION для получения данных из других таблиц. Для построения такой атаки необходимо объединить некоторые приемы, изученные в предыдущих лабораторных работах.

База данных содержит другую таблицу, называемую users, со столбцами username и password.

Чтобы решить эту задачу, выполните SQL-инъекционную UNION-атаку, которая получит все имена пользователей и пароли, и используйте эту информацию для входа в систему под именем администратора.

1.  Используйте Burp Suite, чтобы перехватить и изменить запрос, устанавливающий фильтр категорий товаров.
2. Определите, сколько столбцов возвращает запрос и какие столбцы содержат текстовые данные. Убедитесь, что запрос возвращает два столбца, оба из которых содержат текст, используя в параметре category полезную нагрузку, подобную следующей:
	`'+UNION+SELECT+'abc','def'--`
3. Используйте следующую полезную нагрузку для получения содержимого таблицы пользователей:
	`'+UNION+SELECT+username,+password+FROM+users--`
4. Убедитесь, что в ответе приложения содержатся имена пользователей и пароли.

---

### Получение нескольких значений в одном столбце
В некоторых случаях запрос в предыдущем примере может вернуть только один столбец.

Вы можете получить несколько значений в этом единственном столбце, объединив их вместе. Можно включить разделитель, чтобы разграничить объединенные значения. Например, в Oracle можно ввести:
`' UNION SELECT username || '~' || password FROM users--`

При этом используется двухканальная последовательность ||, которая является оператором объединения строк в Oracle. Введенный запрос объединяет значения полей username и password, разделенные символом ~.

Результаты запроса содержат все имена пользователей и пароли, например:
```
... 
administrator~s3cure
wiener~peter
carlos~montoya
...
```
В разных базах данных используется разный синтаксис для выполнения конкатенации строк. Для получения более подробной информации см. [SQL injection cheat sheet](https://portswigger.net/web-security/sql-injection/cheat-sheet).

---

## Lab: SQL injection UNION attack, retrieving multiple values in a single column
Эта лабораторная работа содержит уязвимость SQL-инъекции в фильтре категорий продуктов. Результаты запроса возвращаются в ответ приложения, поэтому вы можете использовать атаку UNION для извлечения данных из других таблиц.

База данных содержит другую таблицу под названием users со столбцами username и password.

Чтобы решить лабораторную задачу, выполните атаку SQL injection UNION, которая извлекает все имена пользователей и пароли, и используйте эту информацию для входа в систему в качестве пользователя-администратора.

1. Используйте Burp Suite, чтобы перехватить и изменить запрос, устанавливающий фильтр категорий товаров.
2. Определите, сколько столбцов возвращает запрос и какие столбцы содержат текстовые данные. Убедитесь, что запрос возвращает два столбца, только один из которых содержит текст, используя в параметре category полезную нагрузку, подобную следующей:
	`'+UNION+SELECT+NULL,'abc'--`
3. Используйте следующую полезную нагрузку для получения содержимого таблицы пользователей:
	`'+UNION+SELECT+NULL,username||'~'||password+FROM+users--`
4. Убедитесь, что в ответе приложения содержатся имена пользователей и пароли.

---
## Examining the database in SQL injection attacks 
.....скоро.....